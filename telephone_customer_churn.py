# -*- coding: utf-8 -*-
"""Binar DS 3-W Telephone Customer Churn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1a0SAsVYYuLi4eb_i1janRy23HNBjttDg

##**Import Library**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""##**Import Train and Test Dataset**

##**Exploratory Data Analysis (EDA)**
"""

df = pd.read_csv('/Data Train.csv')

from google.colab import drive
drive.mount('/content/drive')

df.info()

df.head()

df.describe()

"""###**Memeriksa Nilai Duplikat**"""

df.duplicated().sum()

"""###**Memeriksa Jumlah Unik Value**"""

df.nunique()

"""###**Mengidentifikasi Korelasi antar Variabel**"""

plt.figure(figsize=(14, 9))
sns.heatmap(df.corr(), annot=True, cmap='Greens');

"""- total_%_charge dan total_%_minutes  berkorelasi (koefisien korelasi = 1)



- nilai total_%_charge dapat ditentukan secara proporsional dengan total_%_minutes, maka tidak perlu melihat kedua kolom.

"""

df.drop(['total_day_charge', 'total_eve_charge', 'total_night_charge', 'total_intl_charge'], axis='columns', inplace=True)
df.head()

"""###**Mengidentifikasi variabel Kunci untuk Memprediksi Churn**

Menghitung koefisien masing-masing variabel dengan reresi logistik untuk menentukan variabel mana yang penting untuk memprediksi churn

```
```

Memvisualisasikan Prosentase Churn
"""

from matplotlib import pyplot as plt
import numpy as np
#Your codes here
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.axis('equal')
labels = ['Yes','No']
churn = df.churn.value_counts()
ax.pie(churn, labels=labels, autopct='%.0f%%')
plt.show()

"""###**Model Regresi Logistik**"""

# scikit-learn
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn import preprocessing

"""1. Kolom yang dikonversi dari churn = ya/tidak ke binary (o dan 1) disimpan secara terpisah"""

df['churn_0_1'] = df['churn'].apply(lambda x: 1 if x == 'yes' else 0)
df[['churn', 'churn_0_1']].head()

"""2. Menyimpan variabel input (x) dan variabel (y) secara terpisah"""

X = df.iloc[:, :-2]  # ~ 'number_customer_service_calls' simpan ke kolom
y = df.iloc[:, -1]  # 'churn_0_1' simpan kolom saja

"""3. Mengubah variabel kategori menjadi variabel dummy"""

# Kolom dengan 3 nilai atau lebih dikonversi ke variabel dummy dengan pd.get_dummies()
X = pd.get_dummies(data=X, columns=['state', 'area_code'])

 # Kolom dengan dua nilai ya dan tidak: ubah ya menjadi 1 dan tidak menjadi 0
X['international_plan'] = X['international_plan'].apply(lambda x: 1 if x == 'yes' else 0)
X['voice_mail_plan'] = X['voice_mail_plan'].apply(lambda x: 1 if x == 'yes' else 0)
X.head()

"""4. Standarisasi input variable

Jika nilai x tidak standar, maka koefisien yang dihitung tidak dapat dibandingkan pada baris yang sama
"""

scaler = preprocessing.StandardScaler()
 X_scaled = scaler.fit_transform(X)

"""5. train_test_split dan running"""

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2)
y_train = y_train.values.ravel()  #ravel(): Fungsi yang meratakan array multidimensi menjadi array satu dimensi.

logistic_model = LogisticRegression(solver='saga', max_iter=2000, penalty='l1')
logistic_model.fit(X_train, y_train)

logistic_model.score(X_test, y_test)  # accuracy_score

"""###**Perbandingan Koefisien Menurut Variabel**"""

# urutkan df dalam urutan nilai koefisien absolut terbesar
temp = pd.DataFrame(list(zip(X.columns, np.absolute(logistic_model.coef_[0]))),
                  columns=['feature', 'coefficient']).sort_values('coefficient', ascending=False).reset_index()

# Visualisasikan hanya 20 variabel teratas dengan koefisien terbesar
plt.figure(figsize=(8, 6))
sns.barplot(data=temp.head(20), y='feature', x='coefficient', palette='Greens_r');

"""voice_mail plan, total_day_minutes, number_customer_service_calls, international_plan, dan number_vmail_messages dinilai sebagai variabel utama dalam memprediksi customer churn

###**Perbandingan Berdasarkan Variabel**

###Rasio churn menurut state
1. Perbandingan rasio churn mingguan
"""

# churn: yes=1, Jika tidak = 0, rata-ratanya sama dengan churn rate.
churn_state = df.groupby(['state'])[['churn_0_1']].mean() * 100
churn_state.rename(columns={'churn_0_1':'churn rate (%)'}, inplace=True)
churn_state.reset_index(inplace=True)

# Urutkan dalam urutan menurun berdasarkan rasio churn
churn_state.sort_values(by='churn rate (%)', ascending=False, inplace=True)
churn_state.head()

# Memeriksa dan memVisualisasikan rasio churn mingguan

plt.figure(figsize=(16, 6))
sns.barplot(data=churn_state, x='state', y='churn rate (%)', palette='Greens_r');

"""- NJ dan CA ditemukan memiliki tingkat churn yang sangat tinggi
- VA dan HI ditemukan memiliki tingkat churn yang sangat rendah

Selanjutnya kita perlu emeriksa apakah state dengan churn rate tinggi sebenarnya memiliki banyak chunners atau hanya karena jumlah pelanggannya sedikit
"""

state_churn_count = pd.pivot_table(data=df, index='state', columns='churn', values='account_length', aggfunc='count').reset_index()
 state_churn_count.sort_values(by='yes', ascending=False, inplace=True)
 state_churn_count.head()

# Memeriksa dan memvisualisasikan jumlah chunners per minggu

plt.figure(figsize=(16, 6))
sns.barplot(data=state_churn_count, x='state', y='yes', palette='Greens_r');

"""- NJ menjadi state dengan jumlah chunners terbanyak.
- VA, HI, dan AK ternyata merupakan state dengan sedikit chunners

###**Tingkat Churn berdasarkan Plan**

voice_mail_plan, international_plan merupakan tingkat churn berdasarkan jenis customer

1. Tingkat churn dengan atau tanpa voice_mail_plan
"""

# churn: yes=1, no=Pada 0, rata-rata sama dengan tingkat churn.
 sns.barplot(data=df, x='voice_mail_plan', y='churn_0_1', palette='Greens');

"""Tingkat customer churn yang tidak menggunakan voice_mail_plan adalah 16%, sedangkan tingkat customer churn yang menggunakan voice_mail_plan adalah sekitar 7%

Uji-t apakah perbedaan rasio signifikan

(Sebenarnya rasio bisa dikatakan konsep yang sama dengan mean, jadi boleh saja menggunakan uji-t seperti perbedaan mean)
"""

import scipy.stats as stats

temp1 = df[df['voice_mail_plan'] == 'yes']
temp2 = df[df['voice_mail_plan'] == 'no']

# Uji varian dengan Levene
lev_result = stats.levene(temp1['churn_0_1'], temp2['churn_0_1'])
print('LeveneResult(F) : %.2f \np-value : %.3f' % (lev_result))

# Menjalankan uji-t sampel independen dengan heterogenitas
 t_result = stats.ttest_ind(temp1['churn_0_1'], temp2['churn_0_1'], equal_var=False)
 print('t statistic : %.2f \np-value : %.3f' % (t_result))

"""p < 0.01 dan terdapat perbedaan yang cukup jauh bahkan jika dilihat secara visual, sehingga dapat dikakatan bahwa customer yang tidak menggunakan voice_mail_plan memiliki churn rate yang lebih tinggi

2. Tingkat churn berdasarkan international_plan
"""

sns.barplot(data=df, x='international_plan', y='churn_0_1', palette='Greens');

"""Tingkat customer churn yang tidak menggunakan international_plan sekitar 11%, sedangkan tingkat customer churn yang menggunakan international_plan sekitar 42%"""

# Uji-t apakah perbedaan rasio signifiikan

temp1 = df[df['international_plan'] == 'yes']
temp2 = df[df['international_plan'] == 'no']

 # Uji varian dengan Levene
lev_result = stats.levene(temp1['churn_0_1'], temp2['churn_0_1'])
print('LeveneResult(F) : %.2f \np-value : %.3f' % (lev_result))

# Menjalankan uji-t sampel independen dengan heterogenitas
 t_result = stats.ttest_ind(temp1['churn_0_1'], temp2['churn_0_1'], equal_var=False)
 print('t statistic : %.2f \np-value : %.3f' % (t_result))

"""- p < 0.01 dan terdapat perbedaan yang besar walaupun dilihat secara visual, sehingga dapat dikatakan bahwa customer yang menggunakan international_plan memiliki churn rate yang lebih tinggi
- Tingkat customer churn yang menggunakan international_plan sebesar 42%, maka perlu memeriksaa faktor ketidakpuasan keseluruhan dari plan tersebut

###**Tingkat Churn sesuai dengan waktu bicara siang hari**

1. Distribusi total_day_minutes dan perbandingan rata-rata berdasarkan churn
"""

fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(10, 5))

sns.boxplot(data=df, x='churn', y='total_day_minutes', palette='Greens', ax=ax1)
sns.barplot(data=df, x='churn', y='total_day_minutes', palette='Greens', ax=ax2)

plt.close(2)
plt.close(3)
plt.tight_layout()

"""Secara keseluruhan total_day_minutes lebih tinggi diantara customer churn

2. Rasio pentalan total_day_minutes berdasarkan kuartil
"""

temp_df = df[['total_day_minutes', 'churn', 'churn_0_1']]

q1, q2, q3 = np.percentile(temp_df['total_day_minutes'], [25, 50, 75])

def get_quarter(x):
    if x < q1: quarter = '1st_q'
    elif x < q2: quarter = '2nd_q'
    elif x < q3: quarter = '3rd_q'
    else: quarter = '4th_q'
    return quarter

temp_df['total_day_minutes_quartile'] = temp_df['total_day_minutes'].apply(lambda x: get_quarter(x))
temp_df.head()

# Memvisualisasikan dan Membandingkan tingkat churn total_day_minutes menurut kuartil

sns.barplot(data=temp_df, y='total_day_minutes_quartile', x='churn_0_1', order=['4th_q', '3rd_q', '2nd_q', '1st_q'], palette='Greens');

"""Secara khusus pelanggan di kuartil dengan total_day_minutes terbanyak memiliki tingkat churn yang tinggi

###**Tingkat Churn berdasarkan  Panggilan Customer Service**

1. Distribusi number_customer_service_calls dan perbandingan rata-rata berdasarkan churn
"""

fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(10, 5))

sns.boxplot(data=df, x='churn', y='number_customer_service_calls', palette='Greens', ax=ax1)
sns.barplot(data=df, x='churn', y='number_customer_service_calls', palette='Greens', ax=ax2)

plt.close(2)
plt.close(3)
plt.tight_layout()

"""Tampak bahwa number_customer_service_calls adalah jumlah keseluruhan panggilan ke Customer Service

2. Distribusi chunners dan non-chunners berdasarkan number)customer_service_calls
"""

plt.figure(figsize=(8, 6))
sns.countplot(data=df, x='number_customer_service_calls', hue='churn', palette='Greens_r');

"""3. Rasio Churn berdasarkan number_customer_service_calls menurut grup"""

# Bagi jumlah panggilan menjadi 4 atau lebih / 3 atau kurang panggilan dan lampirkan keterangannya
temp_df = df[['number_customer_service_calls', 'churn', 'churn_0_1']]
temp_df['customer_service_calls_flag'] = temp_df['number_customer_service_calls'].apply(lambda x: 'more than 4' if x >= 4 else 'less than 3')

# membandingkan number_customer_service_calls berdasarkan Grup churn rate
sns.barplot(data=temp_df, y='customer_service_calls_flag', x='churn_0_1', palette='Greens');

"""50% customer yang telah melakukan panggilan CS 4 atau lebih -> dianggap


membutuhkan manajemen customer experience khusus

###**Rasio Churn berdasarkan Jumlah Pesan Suara**

1. Perbandingan distribusi number_vmail_messages dan rata-rata menurut churn
"""

fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(10, 5))

sns.boxplot(data=df, x='churn', y='number_vmail_messages', palette='Greens', ax=ax1)
sns.barplot(data=df, x='churn', y='number_vmail_messages', palette='Greens', ax=ax2)

plt.close(2)
plt.close(3)
plt.tight_layout()

"""Tampak bahwa number_vmail_messages adalah 0 dalam banyak kasus, karena voice_mail_plan tidak digunakan oleh pelanggan churn

2. membandingkan ketika voice_mail_plan = 0

Jika voice_mail_plan tidak digunakan, vmail_messsages adalah 0
"""

vmail_customer = df[df['voice_mail_plan'] == 'yes']

fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(10, 5))

sns.boxplot(data=vmail_customer, x='churn', y='number_vmail_messages', palette='Greens', ax=ax1)
sns.barplot(data=vmail_customer, x='churn', y='number_vmail_messages', palette='Greens', ax=ax2)

plt.close(2)
plt.close(3)
plt.tight_layout()

"""Saat membandingkan hanya customer yang menggunakan voice_mail_plan, dapat dipastikan bahwa number_vmail_messages tidak berubah secara signifikan tergantung apakah mereka churn atau tidak churn

3. Distribusi churn dan non churn berdasarkan number_vmail_messages

Visualisasi kecuali jika number_vmail_messages = 0 (jumlah kasus sangat banyak 0)
"""

plt.figure(figsize=(15, 6))
 sns.countplot(data=df[df['number_vmail_messages'] != 0], x='number_vmail_messages', hue='churn', palette='Greens_r');

"""4. Perbandingan rasio churn menurut number_vmail_messages"""

plt.figure(figsize=(15, 6))
 sns.barplot(data=df, x='number_vmail_messages', y ='churn_0_1', palette='Greens_r', ci=None);

"""- number_vmail_messages yang rendah tidak berarti banyak, kecuali jika vnumber_vmail_messages = 0
- Tampaknya sulit untuk menentukan apakah customer churn hanya dengan number_vmail_messages
"""